---
title: "積み重なる痕跡"
tags:
  - tech
date: "2025-10-23"
---
<strong><span class="ff7f7e">#</span>現状</strong><br>
新しいノベルゲームを作成している。今までのゲームのような、導入がノベルゲームっぽいけどゲーム部分はしっかり存在するタイプではなく、完全にストーリーのみのゲームだ。<br>
<br>
これにあたり、ノベルゲームのための画面をクリックするとテキストが更新される仕組みをさらにアップデートしたのだが、これにかなりの時間を要した。

<!--more-->

<br>
<strong><span class="ff7f7e">#</span>歴史</strong><br>
僕の初めてのゲームからいくつもノベルゲームっぽいものは作成しており、その度に少しずつ、このテキスト更新のJavaScriptファイルはアップデートされてきた。<br>
<br>
最初のアーニャ・アサーニャゲームでは、画面をクリックすると数字がひとつ増え、テキストが入れられている配列のn番目を表示するというシンプルなものだった。これはクリックされたときに実行される処理で、最初は`let currentOpeningIndex = 0`となっているこの数字で管理している。

```
document.querySelector('#opening-text p').textContent = openingTextArray[currentOpeningIndex];
if (currentOpeningIndex + 1 < openingTextArray.length) {
  currentOpeningIndex += 1;   }
else {
  // ここにシナリオが最後まで行った時の処理を書く
}
```

アサーニャ（アーニャの姿）の立ち絵は`currentOpeningIndex`が特定の数字になったときをifで判定して表示する、というものだった。<br>
<br>
次の月面開発のゲームでは、テキストと関数を一緒に入れた。こうすることで「このテキストと同時にキャラクターを表示する」といったテキストと連動したアクションを起こせる予定だった。予定、と書いたのは、結局このゲームに立ち絵を用意しなかったからだ。この仕組みは次のゲームから活躍する。<br>
<br>
この後の海探索のゲームではテキストとアクションをまとめる仕組みが上手くいった。シナリオデータは以下のようなセットがたくさん入ってる。<br>

```
{ 
  text: '表示するテキスト',
  speaker: '話者名',   // ないならこれは書かない 
  choiceId: '選択肢ID',  // ないならこれは書かない
  action: () => { /* 実行する処理 */ }   // ないならこれは書かない 
}
```

これにより「この時に背景を変える」、「この時にBGMを流す、変える」、「この時に立ち絵を変える」といった多くの設定がテキストと紐づいてセットで配置でき、多くのアクションが開発者に分かりやすく設定できるようになった。<br>
さらに、この時はシナリオ分岐のシステムを追加で実装した。選択肢が設定されている場合は表示し、押したらそれぞれのボタンに設定されている選択肢のルートに切り替わるようになった。これにより`メインシナリオ -> 選択肢 -> ルートA -> メインシナリオ`というような選択肢によってシナリオが変わる、ということが可能になった。<br>
そしてこのスクリプトが最新である。<br>
<br>
<strong><span class="ff7f7e">#</span>今回の機能の追加</strong><br>
まず、シナリオ分岐のシステムを改良した。今の仕組みでは、メインから分岐してさらにメインに戻ってくることはできても、ルートAの中でさらに別のルートに分岐する、ということはできない状態だった。これについては分岐を管理するbranchStackという配列を用意した。分岐に入るたびにそのシナリオとインデックスを保存していく。これにより、メインシナリオからルートA、さらにルートAからルートA-1へと深くネストした分岐も管理できるようになった。

```
let branchStack = []; // 分岐管理

// 選択肢が選ばれた時
branchStack.push({
  scenario: choice.branch,
  index: 0
});
```

これは、ルートBの中でさらにルートCに潜る時、以下のように動作する。

```
branchStack = [
  {
    scenario: [
      { text: 'b-1' },
      { text: 'b-2', choiceId: 'CorD' },
      { text: 'b-3' }
    ],
    index: 2  // b-2まで表示済み。CorDの選択肢を選んでルートCへ
  },
  {
    scenario: [
      { text: 'c-1' },
      { text: 'c-2' }
    ],
    index: 0  // cルートの最初
  }
]
```

問題は「戻る」の機能だった。今回のゲームから「戻る」や「セーブ」などのボタンをテキストの近くに配置した。様々なゲームの画面を見て、ないゲームも多いことに気が付いたのだが、「ノベルゲームらしさ」というものにこだわって実装することにした。<br>
<br>
しかし、これが難しかった。一つ前の状態を一意に特定する機能はないため、`メインシナリオ -> 選択肢 -> ルートA`とたどったときに、これを`ルートA -> メインシナリオの選択肢が表示される地点`と戻るというのは難しいのである。選択肢は以下のようになっていて、先程のテキストとのセットに`choiceId`が設定されている場合は（この場合は）二つのボタンを表示する。

```
選択肢ID: [
  {
    buttonText: '選択肢A',
    branch: [
      { text: 'a-1' },
      { text: 'a-2' },
    ],
  },
  {
    buttonText: '選択肢B',
    branch: [
      { text: 'b-1' },
      { 
        text: 'b-2',
        choiceId: 'whereToGo'
      },
      { text: 'b-3' },
    ],
  },
]
```

そしてこれを見ればわかるが、一つ前の状態を取得することが出来ない。
さらに、「選択肢を押すとヒロインのポイントが増加」みたいな機能があるときに選択肢より前に戻ると、ポイントの無限増加バグが発生する。<br>
<br>
そのため、**戻るボタンでは選択肢より前には戻らない**という挙動が決定した。しかし、更に問題があった。<br>
<br>
上のシナリオデータで、`メインシナリオ -> 選択肢B -> 選択肢whereToGo -> whereToGoのシナリオ終了 -> 選択肢Bの続きの「b-3」`ときて、ここで戻るを押した場合を考える。`branchStack`は以下のようになっている。

```
// whereToGoが終了した後
branchStack = [
  {
    scenario: [
      { text: 'b-1' },
      { text: 'b-2', choiceId: 'whereToGo' },
      { text: 'b-3' }
    ],
    index: 3  // b-3を表示中
  }
]
```

現在選択肢Bのシナリオにいて、「b-3」のテキストが来る3番目を表示中という情報しかない中で一つ前がwhereToGoルートの最後のテキストだと判断するのは難しい[^1]。<br>
<br>
そのため、branchStackではない方法でこれまでたどってきた**すべての**履歴を保存しておく必要があった。ただ、選択肢より前に戻らない、という仕組みも必要であるため、以下のようになった。
 - 画面のテキストを更新する時は、表示したテキストのデータを保存する
 - 戻るボタンを押した時は、このデータを後ろからたどって復元する
   - 表示する時にデータを消していく
 - 選択肢を押すとこのデータが全て消える
   - これによって選択肢より前には戻れない
データは以下のように全てのデータを保存することにした。

```
let displayHistory = [];

// テキスト表示後に状態を記録
displayHistory.push({ 
  scenario: scenario, 
  index: index,
  branchStack: JSON.parse(JSON.stringify(branchStack)),
  openingStoryIndex: openingStoryIndex
});
```

多少無理やりな方法だが、この仕組みにより、複雑にネストした分岐シナリオでも選択肢の直後まで正確に戻ることができるようになった。
<br><br>

[^1]: 前に戻る時に`choiceId`が設定されていればwhereToGoの最後にいることはわかるが、whereToGoでどの選択肢を選んだかはわからない
